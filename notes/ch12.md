## 并发编程
现代操作系统提供了3种基本的方法来构造并发编程：

- 多进程
- I/O多路复用
- 多线程

## 多进程
需要注意的是父进程和子进程都需要小心的关闭文件描述符，因为子进程的文件描述符表和父进程是独立的。

### 一些重要的系统调用

SIGCHID信号:总的意思是指子进程结束。
signal 设置信号的处理方法
fork 方法调用后，下面的代码段就会由子进程来执行

waitpid会暂时停止目前进程的执行，直到有信号来到或子进程结束

pid_t waitpid(pid_t pid,int * status,int options);

waitpid(-1,0,WNOHANG);
-1表示等待任何子进程
WNOHANG表示不会阻塞主进程，立即返回，主进程通过轮询来处理。


###　基于多进程并发编程的优劣：

优点是相互隔离的用户地址空间，因此避免了很多一些复杂的容易出错的共享数据的操作；

缺点也是因为这点，导致共享数据非常苦难，需要依赖IPC:

- 管道
- FIFO
- 系统V共享存储
- 系统V信号量（semaphore）


## I/O多路复用

### 状态机
简单来说一个状态机（state machine）就是一组状态（state）、输入时间（input event）、转移（transition）,其中转移就是将输入事件和状态映射到状态，每一个转移都将一对（输入事件、状态）映射到输出状态。

自循环（self-loop）就是同一输入和输出状态之间的转移。

I/O多路复用就是基于状态机原理来实现事件驱动的，每一个输入事件都伴随着一个状态到另一个状态的迁移，每个客户端都会创建一个状态机，这个状态机绑定到一个文件描述符，文件描述符发生的事件导致它的状态发生改变：等待 -> 可读 -> 等待 ...

	int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); 

select函数就是用来检测这些输入事件发生的：

maxfdp:最大需要检测的文件描述符值；

readfds:需要检测读事件发生的描述符集合；

writefds:需要检测写事件发生的描述符集合；

errorfds:发生错误的文件描述符集合；

timeout:超时时间，NULL一直阻塞，0立即返回。

一般select的用法是阻塞知道指定的集合中至少有一个描述符准备好可读（或可写）才返回，通过副作用，select会修改readfds或writefds指向了**准备好的子集**，这个集合由读（写）集合中准备好读（写）的描述符组成。
因为副作用，所以每次调用select都需要更新读（写）集合。

集合只能通过以下几个宏来操作：

FD_ZERO(fd_set *fdset) 初始化整个集合
FD_CLR(int fd,fd_set *fdset) 初始化集合中fd索引位置
FD_SET(int fd,fd_set *fdset) 设置集合中fd索引位置
FD_ISSET(int fd,fd_set *fdset) 集合中fd索引位置是否是1，也就是是否可读（或可写）



###　基于I/O多路复用并发编程的优劣：
优点是不需要多进程那样代价很大的上下文切换
缺点是编程会很复杂，粒度越细的多路复用，程序就会越复杂。


## 多线程


### POSIX线程

	int pthread_create(pthread_t *tid,pthread_attr_t *attr,func *f,void *arg)

tid:包含新创建线程的pid

attr:线程的属性

f:void *thread_routine(void *vargp) 叫做线程例程（thread routine）就是线程执行的代码块。

arg:传递给thread routine的参数

	pthread_t pthread_self(void)

新线程可以通过pthread_self获得自己的线程ID。


### 线程终止
和父进程创建子进程不一样，创建的新线程和主线程是对等的关系，之所以叫主线程只是因为它是第一个创建的线程。
线程终止：
- 线程执行的例程结束
- 主线程执行pthread_exit,它会等待其他所有的对等线程结束
- 线程通过pthread_cancle同终止当前线程


### 回收终止线程的资源
主线可以通过pthread_join等待指定线程结束


### 线程分离

任何一个时间点上线程是可结合和可分离的。前者需要其他线程来释放其占用的资源，后者则线程终止后系统会自动回收期资源，所以一般程序（比如web服务）创建的线程都会分离出去，这样主线程就不要关心其他线程什么时候结束了。


###　基于线程并发编程的优劣：
优点是所有线程共享进程地址空间，共享信息很简单，相比进程上下文切换成本小很多。

缺点就是多线程共享数据带来很多并发竞争问题。