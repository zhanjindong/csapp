## 并发编程
现代操作系统提供了3种基本的方法来构造并发编程：

- 多进程
- I/O多路复用
- 多线程

## 多进程
需要注意的是父进程和子进程都需要小心的关闭文件描述符，因为子进程的文件描述符表和父进程是独立的。

### 一些重要的系统调用

SIGCHID信号:总的意思是指子进程结束。
signal 设置信号的处理方法
fork 方法调用后，下面的代码段就会由子进程来执行

waitpid会暂时停止目前进程的执行，直到有信号来到或子进程结束

pid_t waitpid(pid_t pid,int * status,int options);

waitpid(-1,0,WNOHANG);
-1表示等待任何子进程
WNOHANG表示不会阻塞主进程，立即返回，主进程通过轮询来处理。


###　基于多进程并发编程的优劣：

优点是相互隔离的用户地址空间，因此避免了很多一些复杂的容易出错的共享数据的操作；

缺点也是因为这点，导致共享数据非常苦难，需要依赖IPC:

- 管道
- FIFO
- 系统V共享存储
- 系统V信号量（semaphore）


## I/O多路复用

### 状态机
简单来说一个状态机（state machine）就是一组状态（state）、输入时间（input event）、转移（transition）,其中转移就是将输入事件和状态映射到状态，每一个转移都将一对（输入事件、状态）映射到输出状态。

自循环（self-loop）就是同一输入和输出状态之间的转移。

I/O多路复用就是基于状态机原理来实现事件驱动的，每一个输入事件都伴随着一个状态到另一个状态的迁移，每个客户端都会创建一个状态机，这个状态机绑定到一个文件描述符，文件描述符发生的事件导致它的状态发生改变：等待 -> 可读 -> 等待 ...

	int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); 

select函数就是用来检测这些输入事件发生的：

maxfdp:最大需要检测的文件描述符值；

readfds:需要检测读事件发生的描述符集合；

writefds:需要检测写事件发生的描述符集合；

errorfds:发生错误的文件描述符集合；

timeout:超时时间，NULL一直阻塞，0立即返回。

一般select的用法是阻塞知道指定的集合中至少有一个描述符准备好可读（或可写）才返回，通过副作用，select会修改readfds或writefds指向了**准备好的子集**，这个集合由读（写）集合中准备好读（写）的描述符组成。
因为副作用，所以每次调用select都需要更新读（写）集合。

集合只能通过以下几个宏来操作：

FD_ZERO(fd_set *fdset) 初始化整个集合
FD_CLR(int fd,fd_set *fdset) 初始化集合中fd索引位置
FD_SET(int fd,fd_set *fdset) 设置集合中fd索引位置
FD_ISSET(int fd,fd_set *fdset) 集合中fd索引位置是否是1，也就是是否可读（或可写）



###　基于I/O多路复用并发编程的优劣：
优点是不需要多进程那样代价很大的上下文切换
缺点是编程会很复杂，粒度越细的多路复用，程序就会越复杂。


## 多线程


### POSIX线程

	int pthread_create(pthread_t *tid,pthread_attr_t *attr,func *f,void *arg)

tid:包含新创建线程的pid

attr:线程的属性

f:void *thread_routine(void *vargp) 叫做线程例程（thread routine）就是线程执行的代码块。

arg:传递给thread routine的参数

	pthread_t pthread_self(void)

新线程可以通过pthread_self获得自己的线程ID。


### 线程终止
和父进程创建子进程不一样，创建的新线程和主线程是对等的关系，之所以叫主线程只是因为它是第一个创建的线程。
线程终止：
- 线程执行的例程结束
- 主线程执行pthread_exit,它会等待其他所有的对等线程结束
- 线程通过pthread_cancle同终止当前线程


### 回收终止线程的资源
主线可以通过pthread_join等待指定线程结束


### 线程分离

任何一个时间点上线程是可结合和可分离的。前者需要其他线程来释放其占用的资源，后者则线程终止后系统会自动回收期资源，所以一般程序（比如web服务）创建的线程都会分离出去，这样主线程就不要关心其他线程什么时候结束了。


###　基于线程并发编程的优劣：
优点是所有线程共享进程地址空间，共享信息很简单，相比进程上下文切换成本小很多。

缺点就是多线程共享数据带来很多并发竞争问题。

**除了I/O多路复用，多线程也可以实现事件驱动程序**


## 进度图

**临界区（critical section）** 一个线程操作共享变量构成的，翻译成临界边其实更合适，因为它其实是一条轨迹
**不安全区（unsafe region）** 临界区的交集，不安全区是针对共享变量在多线程访问下的概念。
**禁止区（forbidden region）** 进度图中PV操作保护起来互斥的区域，禁止区完全包含了不安全区




## 线程同步

### 基于信号量的PV操作

P:存在共享变量s为非负值，如果s为0则线程挂起等待，否则将s减1；
V:将s加1，如果存在线程等待s变成非负值则随机重启一个线程。

PV操作本身是unfair的。

根据s的值的不同分为：
二元信号量：用来互斥，互斥锁，二元信号量的P操作就是**加锁**，V操作就是**解锁**
计数信号量


利用信号量可以实现两种经典的并发问题：
生产者-消费者：利用互斥锁 和 计数信号量
读者-写者：写者必须拥有互斥锁，但是可以有任意个读者同时访问临界区，读写之间也是互斥的。 该问题又分为两类：读者优先 和 写者优先。

饥饿（starvation）：一个线程无限期的阻塞，无法进展。


## 并行程序效率衡量标准

加速比（speedup）：程序在顺序执行和并执行下所花费的时间比，加速比越大越好。加速比有时称为强扩展（strong scaling）：绝对加速比 和 相对加速比
绝对加速比就是用一个程序的顺序版本和并行版本作比较，而相对加速比的测量都是用并行版本，绝对加速比比相对加速比更真实反映并行程序的好处但是也更难测量。


效率（efficiency） = 加速比/核数，用来衡量程序在有用的工作上花费的时间，所以说效率越高越好，意味着在同步和通信上花费的时间越少。


弱扩展（weak scaling）：增加处理器的数量的同时增加问题规模，这时再来考察加速比和效率。一般来说弱扩展更符合我们真实的要求，因为大多数情况并行就是为了能够处理更大规模的问题。


## 并发问题

###　线程安全 和 线程不安全
可重入通常作为线程安全的同义词但其实它 是 线程安全的一个子集。 可重入：分为显示可重入（所有的变量都是值传递，且在栈中）和隐式可重入（参数是引用传递，如指针，这就依赖传递进来的引用是否是共享的）

可重入的函数通常比不可重入的线程安全函数高效些，因为不需要同步。

线程不安全的函数有4类：不保护共享变量、保持跨越多个调用状态的、返回一个指向静态变量指针的、调用线程不安全函数的

unix为大多数库中线程不安全的函数都提供了一个线程安全的版本，都以_r结尾。

### 饥饿
一个线程无限期的阻塞，无法进展。

### 竞争
当一个程序的正确性依赖于一个线程要在另一个线程达到y点之前达到控制流的x点。


### 死锁
一组线程等待一个不可能发生的条件从而都阻塞了。跟饿死不同，饿死可能只是一个线程。

通过进度图可以很容看到死锁，死锁是两个**禁止区**发生特定重叠导致的（发生重叠不一定就会死锁），重叠的禁止去组成了**死锁区域**。

### 避免死锁

互斥锁通过加锁顺序上的控制可以避免死锁：给所有锁分配一个全序，所有线程按照这个顺序加锁，必须先对s加锁，再对t加锁就肯定不会出现死锁。

一图胜千言。

![12-43][1]


 [1]: https://github.com/zhanjindong/csapp/blob/master/images/12-43.jpg